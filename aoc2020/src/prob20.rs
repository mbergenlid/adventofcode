use regex::Regex;
use std::collections::HashMap;
use std::ops::AddAssign;
use std::str::FromStr;
use crate::prob20::Op::{Rotate, Flip};

pub fn solve_part_1(input: &str) -> u64 {
    let tiles = input
        .split("\n\n")
        .map(|s| s.parse::<Tile>().unwrap())
        .map(|t| (t.id, t))
        .collect::<HashMap<_, _>>();

    let mut image = Image {
        size: (tiles.len() as f64).sqrt().round() as usize,
        layout: vec![None; tiles.len()],
        tiles,
    };

    if image.find_solution(0) {
        image.layout[0].as_ref().unwrap().id
            * image.layout[image.size - 1].as_ref().unwrap().id
            * image.layout[image.size * (image.size - 1)]
                .as_ref()
                .unwrap()
                .id
            * image.layout[image.size * image.size - 1]
                .as_ref()
                .unwrap()
                .id
    } else {
        panic!("Could not find solution")
    }
}

pub fn solve_part_2(input: &str) -> usize {
    let tiles = input
        .split("\n\n")
        .map(|s| s.parse::<Tile>().unwrap())
        .map(|t| (t.id, t))
        .collect::<HashMap<_, _>>();

    let mut image = Image {
        size: (tiles.len() as f64).sqrt().round() as usize,
        layout: vec![None; tiles.len()],
        tiles,
    };

    assert!(image.find_solution(0));

    let mut total_image_content = Vec::new();
    for row in 0..image.size {
        let mut acc = vec![String::new(); 8];
        for tile in image.layout[row * image.size..]
            .iter()
            .take(image.size)
        {
            let tile = tile.as_ref().unwrap();
            let mut content = tile.content.clone();
            for op in tile.orientation.iter() {
                match op {
                    Rotate => content.rotate(),
                    Flip => content.flip(),
                }
            }

            for (index, line) in acc.iter_mut().enumerate() {
                line.add_assign(&content[index]);
            }
        }
        total_image_content.append(&mut acc);
    }

    let mut image2 = Image2 {
        lines: total_image_content,
    };

    for _ in 0..2 {
        for _ in 0..4 {
            let sea_monsters: usize = (1..image2.lines.len() - 1)
                .map(|y| image2.count_sea_monster_at(y))
                .sum::<usize>();
            if sea_monsters != 0 {
                return image2
                    .lines
                    .iter()
                    .map(|line| line.chars().filter(|c| *c == '#').count())
                    .sum::<usize>()
                    - sea_monsters * 15;
            }
            image2.rotate();
        }
        image2.flip();
    }

    panic!("No sea monsters found")
}

trait ImageContent {
    fn rotate(&mut self);
    fn flip(&mut self);
}

impl ImageContent for Vec<String> {
    fn rotate(&mut self) {
        let mut new_lines = Vec::new();
        for row in 0..self.len() {
            let mut line = String::new();
            for c in self.iter().rev().map(|s| s.chars().nth(row).unwrap()) {
                line.push(c);
            }
            new_lines.push(line);
        }
        *self = new_lines;
    }

    fn flip(&mut self) {
        for line in self.iter_mut() {
            *line = line.chars().rev().collect();
        }
    }
}

struct Image2 {
    lines: Vec<String>,
}

impl Image2 {
    fn count_sea_monster_at(&self, y: usize) -> usize {
        let line1 = self.lines.get(y - 1).unwrap();
        let line2 = self.lines.get(y).unwrap();
        let line3 = self.lines.get(y + 1).unwrap();

        lazy_static! {
            static ref LINE_1: Regex = Regex::new(r"^.{18}#").unwrap();
            static ref LINE_2: Regex = Regex::new(r"#.{4}##.{4}##.{4}###").unwrap();
            static ref LINE_3: Regex = Regex::new(r"^.#.{2}#.{2}#.{2}#.{2}#").unwrap();
        }

        let mut count = 0;
        let mut current = 0;
        while let Some(m) = LINE_2.find(&line2[current..]) {
            if LINE_3.is_match(&line3[current + m.start()..])
                && LINE_1.is_match(&line1[current + m.start()..])
            {
                count += 1;
            }
            current += m.start() + 1;
            if current + 20 >= line2.len() {
                return count;
            }
        }
        return count;
    }

    fn rotate(&mut self) {
        let mut new_lines = Vec::new();
        for row in 0..self.lines.len() {
            let mut line = String::new();
            for c in self.lines.iter().rev().map(|s| s.chars().nth(row).unwrap()) {
                line.push(c);
            }
            new_lines.push(line);
        }
        self.lines = new_lines;
    }

    fn flip(&mut self) {
        for line in self.lines.iter_mut() {
            *line = line.chars().rev().collect();
        }
    }
}

struct Image {
    size: usize,
    layout: Vec<Option<Tile>>,
    tiles: HashMap<u64, Tile>,
}

impl Image {
    fn find_solution(&mut self, index: usize) -> bool {
        if index >= self.size * self.size {
            return true;
        }
        let mut keys_left = self.tiles.keys().cloned().collect::<Vec<_>>();
        keys_left.sort();
        for tile_id in keys_left {
            let mut tile = self.tiles.remove(&tile_id).unwrap();
            for _ in 0..2 {
                for _ in 0..4 {
                    if self.fits(&tile, index) {
                        self.layout[index] = Some(tile);
                        if self.find_solution(index + 1) {
                            return true;
                        }
                        tile = self.layout[index].take().unwrap()
                    }
                    tile.rotate();
                }
                tile.flip();
            }
            self.tiles.insert(tile_id, tile);
        }
        return false;
    }

    fn fits(&self, tile: &Tile, index: usize) -> bool {
        if index == 0 {
            true
        } else {
            if index % self.size != 0 {
                let to_left = self.layout[index - 1].as_ref().unwrap();

                if to_left.right.0 != tile.left.0 {
                    return false;
                }
            }
            if index >= self.size {
                let above = self.layout[index - self.size].as_ref().unwrap();
                if above.bottom.0 != tile.top.0 {
                    return false;
                }
            }
            return true;
        }
    }
}

#[derive(Debug, Eq, PartialEq, Clone)]
enum Op {
    Rotate,
    Flip,
}

#[derive(Debug, Eq, PartialEq, Clone)]
struct Tile {
    id: u64,
    top: (u16, u16),
    bottom: (u16, u16),
    right: (u16, u16),
    left: (u16, u16),

    orientation: Vec<Op>,

    content: Vec<String>,
}

impl Tile {
    fn rotate(&mut self) {
        let temp = (self.right.0, self.right.1);
        self.right = (self.top.0, self.top.1);
        self.top = (self.left.1, self.left.0);
        self.left = (self.bottom.0, self.bottom.1);
        self.bottom = (temp.1, temp.0);

        self.orientation.push(Rotate);
        // let mut new_lines = Vec::new();
        // for row in 0..self.content.len() {
        //     let mut line = String::new();
        //     for c in self.content.iter().rev().map(|s| s.chars().nth(row).unwrap()) {
        //         line.push(c);
        //     }
        //     new_lines.push(line);
        // }
        // self.content = new_lines;
    }

    fn flip(&mut self) {
        let temp = self.right;
        self.right = self.left;
        self.left = temp;
        self.top = (self.top.1, self.top.0);
        self.bottom = (self.bottom.1, self.bottom.0);

        self.orientation.push(Flip);
        // for line in self.content.iter_mut() {
        //     *line = line.chars().rev().collect();
        // }
    }
}

impl FromStr for Tile {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        lazy_static! {
            static ref REGEX: Regex = Regex::new(r"Tile (\d+):").unwrap();
        };
        let id = REGEX
            .captures(s.lines().next().unwrap())
            .unwrap()
            .get(1)
            .unwrap()
            .as_str()
            .parse::<u64>()
            .unwrap();
        let top = u16_from_string(s.lines().nth(1).unwrap().chars());
        let right = u16_from_string(s.lines().skip(1).map(|l| l.chars().last().unwrap()));
        let bottom = u16_from_string(s.lines().last().unwrap().chars());
        let left = u16_from_string(s.lines().skip(1).map(|l| l.chars().next().unwrap()));
        Ok(Tile {
            id,
            top,
            bottom,
            right,
            left,
            orientation: Vec::new(),
            content: s
                .lines()
                .skip(2)
                .take(8)
                .map(|line| line[1..line.len() - 1].to_string())
                .collect(),
        })
    }
}

fn u16_from_string<I: Iterator<Item = char>>(chars: I) -> (u16, u16) {
    let (value1, value2, _) = chars.fold((0u16, 0u16, 1u16), |(acc1, acc2, mul), c| match c {
        '.' => (acc1 * 2 + 0, 0 * mul + acc2, mul * 2),
        '#' => (acc1 * 2 + 1, 1 * mul + acc2, mul * 2),
        _ => panic!(""),
    });
    (value1, value2)
}

#[cfg(test)]
mod test {
    use crate::prob20::{solve_part_1, solve_part_2, Image2, Tile, ImageContent};
    use crate::prob20::Op::Rotate;

    const TILE_PARSE_TESTCASE: &str = "Tile 3469:
.##..#.#.#
##..#...##
...#..##.#
....#.#..#
#..#.##...
.#.##.#.##
..#.#.....
..###.#..#
#.##.#...#
....#...##";

    #[test]
    fn test() {
        assert_eq!(
            TILE_PARSE_TESTCASE.parse::<Tile>().unwrap(),
            Tile {
                id: 3469,
                top: (0b0110010101, 0b1010100110),
                right: (0b1111010111, 0b1110101111),
                bottom: (0b0000100011, 0b1100010000),
                left: (0b0100100010, 0b0100010010),
                orientation: vec![],
                content: vec![
                    "#..#...#".to_string(),
                    "..#..##.".to_string(),
                    "...#.#..".to_string(),
                    "..#.##..".to_string(),
                    "#.##.#.#".to_string(),
                    ".#.#....".to_string(),
                    ".###.#..".to_string(),
                    ".##.#...".to_string(),
                ]
            }
        );

        let mut tile = TILE_PARSE_TESTCASE.parse::<Tile>().unwrap();
        tile.rotate();
        assert_eq!(
            tile,
            Tile {
                id: 3469,
                top: (0b0100010010, 0b0100100010),
                right: (0b0110010101, 0b1010100110),
                bottom: (0b1110101111, 0b1111010111),
                left: (0b0000100011, 0b1100010000),
                orientation: vec![Rotate],
                content: vec![
                    "#..#...#".to_string(),
                    "..#..##.".to_string(),
                    "...#.#..".to_string(),
                    "..#.##..".to_string(),
                    "#.##.#.#".to_string(),
                    ".#.#....".to_string(),
                    ".###.#..".to_string(),
                    ".##.#...".to_string(),
                ]
            }
        );
    }

    #[test]
    fn test_1() {
        let mut vec = vec![
            "#..#...#".to_string(),
            "..#..##.".to_string(),
            "...#.#..".to_string(),
            "..#.##..".to_string(),
            "#.##.#.#".to_string(),
            ".#.#....".to_string(),
            ".###.#..".to_string(),
            ".##.#...".to_string(),
        ];
        let mut vec2 = vec.clone();

        vec.rotate();
        vec.flip();

        vec2.rotate();
        vec2.flip();
        vec2.rotate();
        vec2.flip();
        vec2.rotate();
        vec2.flip();
        vec2.rotate();
        vec2.rotate();
        println!("{:?}", vec);
        assert_eq!(vec, vec2);
    }

    const TESTCASE_1: &str = "Tile 2311:
..##.#..#.
##..#.....
#...##..#.
####.#...#
##.##.###.
##...#.###
.#.#.#..##
..#....#..
###...#.#.
..###..###

Tile 1951:
#.##...##.
#.####...#
.....#..##
#...######
.##.#....#
.###.#####
###.##.##.
.###....#.
..#.#..#.#
#...##.#..

Tile 1171:
####...##.
#..##.#..#
##.#..#.#.
.###.####.
..###.####
.##....##.
.#...####.
#.##.####.
####..#...
.....##...

Tile 1427:
###.##.#..
.#..#.##..
.#.##.#..#
#.#.#.##.#
....#...##
...##..##.
...#.#####
.#.####.#.
..#..###.#
..##.#..#.

Tile 1489:
##.#.#....
..##...#..
.##..##...
..#...#...
#####...#.
#..#.#.#.#
...#.#.#..
##.#...##.
..##.##.##
###.##.#..

Tile 2473:
#....####.
#..#.##...
#.##..#...
######.#.#
.#...#.#.#
.#########
.###.#..#.
########.#
##...##.#.
..###.#.#.

Tile 2971:
..#.#....#
#...###...
#.#.###...
##.##..#..
.#####..##
.#..####.#
#..#.#..#.
..####.###
..#.#.###.
...#.#.#.#

Tile 2729:
...#.#.#.#
####.#....
..#.#.....
....#..#.#
.##..##.#.
.#.####...
####.#.#..
##.####...
##..#.##..
#.##...##.

Tile 3079:
#.#.#####.
.#..######
..#.......
######....
####.#..#.
.#...#.##.
#.#####.##
..#.###...
..#.......
..#.###...";

    #[test]
    fn test_part_1() {
        assert_eq!(solve_part_1(TESTCASE_1), 20899048083289);
    }

    #[test]
    fn test_find_sea_monster() {
        let image = Image2 {
            lines: ".####...#####..#...###..
#####..#..#.#.####..#.#.
.#.#...#.###...#.##.##..
#.#.##.###.#.##.##.#####
..##.###.####..#.####.##
...#.#..##.##...#..#..##
#.##.#..#.#..#..##.#.#..
.###.##.....#...###.#...
#.####.#.#....##.#..#.#.
##...#..#....#..#...####
..#.##...###..#.#####..#
....#.##.#.#####....#...
..##.##.###.....#.##..#.
#...#...###..####....##.
.#.##...#.##.#.#.###...#
#.###.#..####...##..#...
#.###...#.##...#.######.
.###.###.#######..#####.
..##.#..#..#.#######.###
#.#..##.########..#..##.
#.#####..#.#...##..#....
#....##..#.#########..##
#...#.....#..##...###.##
#..###....##.#...##.##.#"
                .lines()
                .map(|l| l.to_string())
                .collect::<Vec<_>>(),
        };

        assert_eq!(image.count_sea_monster_at(3), 1);
        assert_eq!(image.count_sea_monster_at(17), 1);
    }

    #[test]
    fn test_part_2() {
        assert_eq!(solve_part_2(TESTCASE_1), 273);
    }

    const TESTCASE_2: &str = "..#.#....##.#...#.##...............####...#....#..##.#.##.....##.##...#.##......#...............
##......#..........#.###..##.....#.....##.....#............#..#......#..#.................#.....
..#....#.....##.......#....##....###...##....###..#.#......##.....##......#.##......##.#.#.#.#.#
..#....###..#.#..#........#..#..#..#.###.#.##...........#...............#......#.#...........#..
#........#........#....#.#...#.#....#......#...##.#.#..#.#.#...........#.....#....#..#..#.....#.
#..#...#####..........#.#...#........#..#.#.........#.....#.....#....##..####...####..#.#.......
#...#...##.#...........#..............###..####..#.###...###....##.##..####.##..#.......#.#..#.#
#....#....##....##...####..#.###...#....##.##..#..#.##..#..###..#...#.......#..#....##...#......
....#.#..#..#..#..#..#.#...#........#..#...........#......##.#.....#......#....#.....#.......#.#
....#..#..........#.............##.......#..#...#.#........##..#.##........##.........#.........
........###............###.......#.......#....#........#..#...###..#.##.#..###..#.#....#.....#..
......#...##..##........#..#.##...#.........#......#.#.....##.#..#..#..#.##..............#.###.#
.....#...#...###.#..##...####....#....##..#.##......##.#.##.#...#.#...#.......#...#.............
..#.#....##.##..#.##..#..#..##..#....#..#.....#..#......##.##......#.#......#.......#.#.........
..........#.#.....#...#......#...............##.#..#...##...##.##.##....#............#........#.
#....##.#....#........##.##.#......#.#....#.#....###.#..#..###..#.....#..................##..#.#
......#.....#..........#....#....#.#.#...#............#...##.......#.###...#...##.#...#.#.......
.....#.......#.......##...##...#..................#.#..##...#...##.#..........#..#.#..#....#..#.
....#.#...#....##..............#.....#.#.###.#.###.#.####..#.#......####.#.####...#....#..#...#.
..#....#............#......#...#......#..##.#.##..#.##............##....#...#...#.##.#....##.#.#
.....####........#....#..#..........#.......#.....#.....#...#.#...###.#..###.#.###...##.#.......
......#....#...##.#..##.#.....#.##......#.#.........#..#.......##.#..#..##.##.#..#.....#.#.....#
#....#.###.....#....###...##..#.###..#...##.#..###.#....####.###..##....###......#......##...#.#
............#...####..##.#..#.###...#.#...##.#....#...#...#.#......#.......#...#.....#..........
.#...........#..#..#........#....###....####........#............##.......#......#......#..#..#.
.#.........##....#.#........###....#.#...##.....#...##.#.......##.....#..##...###.#####..####...
..#....#....#.......#..#....#..#..............#.......#....#..............#..#..#..#..#.##....#.
.#........#.#.###.#.###....####.#..#..........####.#.#............#...#...#.##......#...##.#.#..
.......#...#..#..#..#..#.##...............#..##........#...#..#..............#....#....#..#..#.#
##.#.#........#..#..#....#............###..#.........##..#...#............##...##.....##....#...
.....#..............#....#........#............#..#..........##.#..####..###...###..#..#......##
#..#.......#........#....#...##.....#...#.......##...#.....#.###.###.#..#..#..#...#.....#...##.#
.........#...#.##....#.......#.###.#...#......#....####.#...#........##...##...#..#...#.#.#.....
.##....##...#..#....###...##....####...........##........#...#............#.#.#.#.....#....##..#
...#....#..#..#.#..#.##.##..#..#..#..#.#.........#......#..........#..#......##.#...#...........
#......#.#..##.........#......................#...#.#.......##.#.#........#..#.##........#......
..#.#.....#...#......##........##.....#....#..#.##..#.####..###.....#...#..##.##.............#..
......#.#...#.#............#.##......#....#.#.##..#..#..##.#...#......#..#......................
.....#.#........##.......#.......##..#..#..............#......###....#.......##..#...#.....##...
...#...#....##..#.###.#.###..##.#..#....#....#.#............##.........#....#...#...#........#..
..##....#..##.#.##..#..#..##.#...#.##.....##............#.....#...#....##...####...####..#.#....
#.##...#......#.....#..##.....#..##.#.....#.......#.#.....#.#....#.#..#..##.#.##.##..#...#.....#
.##..##.###.#...........#...............#.....#....#...#......#.#....#..#.#...................#.
....#....##...#.#...............#...#..........#......###......#......#.#..#.....##..#..........
.......#..#.#.#.........#.#.......#.#...##.#.#........#...##..#..#...#...#.............#......#.
...#...#.....##.#.##.#......###.....#...####...##....####.........#......#.##.......#.......#...
#.....#....#..#.##..#.###...####...#.#..#..#.##..#.###.#...##..............##.....##.....#.....#
.#.........##.##..#..#..#.##......##.##.#...#.#....####.........#.....#.......................#.
.#..#.#..#.....#.#....#.##............#.......#....#.#...##..............#....####........#.....
.........#............#.#...#.#............#.#.#.......#.#.....##...##....##....###..........#.#
.#..#....#.##....................#..##....##..####...####...##..##.#.##..#..##.#....#...........
.#...#.........#.####.....#........#..#..##.#.##.##.##......#......#...#.#.......#.......##.....
...#...#.#....#..#...#.....#........#.......#...#.#..#......#....#.#..#.......#....##...........
...#....##.#...#..........#.#..#.#.##...........#...#..#.#..##.......#.#..#.#.#.#..#............
.....#....#..#.##.#####....###......#...#..#....###...##....###...#..........#...###....#.....#.
.........#.#..#..#..##.##.#..#.#........#.#.#..#..#..#..#..#.........#..........#...#.......#...
....#.......#.#...##.#......#...##..#..........#...#...#..#.#.....#....##.##.##.#..###...#..#...
..........#....##.##....#......#..#.#..#.......#.#........#..#..#.##..#..##.#..#..#.#.........##
.#................##...#....#.##.##.###..#.#.....#...#....#.#.#.........###.....#.#.....#..#....
..#...#...#...#.....#..#....#.#....###.#..#.......#...#.....##.#.#...#.#..#...##.#...#...#......
.#..........##.#........#....##....##.#..####........#.........#..#....#..#.##..#....#..#.......
#...#...##....#..#.#.....#..#..#.##..#.##...#..#.....#.#..##....##....###...........#......##...
...#..........#......##.........#...........##.##..##.#.#####..##.##.#.#..##..##....#......#....
#......#...........#....#...#...###........##.....#...#.........#.#..........##.............#.#.
..#.....#......#.#.........#..#......#.....#.#..#.#....##.......##..#..........#.#.##.#...#.....
........#..#....#......##............#........................##..#......#........#.....#.......
#.....#..###......##...###..#..#..#....#....##....##....###..####.#.....#....#...#.#.#....##....
....##......#...##...###...##....###..##..#...####..##.#.##..##......#..###......#...#......#...
#.#...........#.###.#..#..####..#.......#..#..#....................#..#.##....##....###.......#.
#...#.....#...#......###.#..............###.#...................#..##.##..#..#..#..#.#.##..####.
.....#....#.....#..#........#......#...#.##....#..#.#...#..#..#.......#....#...........#.###.#..
#.#.........###...###.#..#..#....#..........#...##..#.###..#......#........#....##..#..#....#.#.
.....#......#......#..........#..#..#....##.#..###...###...........#...#..#.#..##....##....###.#
.......#...##.##.#...#....#...##.....#..#..#..#.###.#...#........#..#.#.#.###.#..#..#..#.##..#..
..#........#.........#.###.#......##...#.....##..#.#...#.........####......#..##..#.#...#..#....
##...#...............#.#.#.#..#..##.###...#...#....#.........#..###..#....#.#..............###..
.#.#......#..........#......#....#...#.#......##.....#.##...........##..#....##.....##.....#..##
........###..####....##...####........#.#......#.........#........#.#.....#..#...#..#......#....
....#..#...#..#..#.##..#..#........#......#......#..#.............##..#....#.....#.#......#...#.
..#....#...#.##....#...##.#...#.....#.........#......#...#.#..##..#.##....###.#.....#..#........
..#........#.#.......#....#.#..##......#.###...#.###......#..#..#..#..#..##..#......#.#.........
.....#.#......#..##................#..#....#.#.....#.....#..#..##..#............#....#.#.#.....#
....#............#.#.....#.##..#..#.........#..#...####.#........#....#....#..#.#.#..##.#.....##
..#....#..........#....#..##.......#.#.###.............#.#....#.....##..#.##.#..................
....#..#.#..#..#.#...#...........##......#............#.#####....##.#..####................#....
...#......#.....#....##.#..###..####......#.####...#...#..#..#..#..#..#..#.....#...#......##..#.
..#...##...#...#.#..#..#..#..#..#....#..#..#.#.......#.#............#..........##.....#.#..#..##
..#...#..........#.......##..#...##.....###..#...#..###.........#..#...#...#.#......##..#.##....
#.##......#..##..#....###...#..#...#.....##.................#.....#.#..................##.......
.#......#...#........##.....#......#...#.#...#..#....##....##....####..#..........#.#.#.....#..#
....#....##...###.##.###.#...#.#.#.#.#...##.....##.###.#..#..#..#...#..#.....##.##..##...#.#....
...#.#..##.#.##..#..#......#....#..................#...........#..##.###....###..###.#..###.##.#
.#....#...#.#.......#...#.......#..#......##....##.##......#.........##.#..#.##..#.##..#.##..##.
..........#.......##.........#....#......#........##....#..#.............#.##..###....##.#......
##..............#.....#......#.###.##.......#...........#...###..#................##.....#...#..
......#..#....#.#.#..#..#....#..#...#..#......##...#.......#....##..................#.#..##...#.";

    #[test]
    fn debug_part_2() {
        let image = Image2 {
            lines: TESTCASE_2
                .lines()
                .map(|l| l.to_string())
                .collect::<Vec<_>>(),
        };

        for line in image.lines.iter() {
            println!("{}", line);
        }
        println!(
            "{}",
            (1..image.lines.len() - 1)
                .map(|y| image.count_sea_monster_at(y))
                .sum::<usize>()
        );
    }
}
